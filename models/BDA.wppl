// run using:
// webppl BDA.wppl --require ./refModule/ -- --modelVersion <colorSize> --costs <fixed> --semantics <empirical> 

// modelVersion can be <colorSize> <typicality> <nominal>
// costs can be <fixed> <empirical>
// semantics can be <fixed> <empirical> <fixedplusempirical>

// Fix some configuration options
var config = {
  'modelVersion' : argv.modelVersion,
  'costs' : argv.costs,
  'semantics' : argv.semantics
};

// Pull in requested data/conditions 
var data = refModule.getData(config.modelVersion);
console.log("Loading data... found" + data.length + " data points");

var conditions = refModule.getConditions(config.modelVersion);
console.log("Loading unique conditions... found" + conditions.length);

var paramPrior = function() {
  // Params shared by all versions of the model
  var baseParams = {
    infWeight : uniformDrift({a: 0, b: 20, w: 3})
  };

  var costParams = (config.costs === 'fixed'  ? {

    colorCost :       uniformDrift({a: 0, b: 10, w: 40/20}),
    sizeCost :        (config.modelVersion == 'colorSize' ?
		       uniformDrift({a: 0, b: 10, w: 40/20}) :
		       0),
    typeCost :        (config.modelVersion == 'typicality' ?
		       uniformDrift({a: 0, b: 10, w: 40/20}) :
		       0)
  } : config.costs === 'empirical' ? {

    lengthCostWeight : uniformDrift({a: 0, b: 5, w: 1}),
    freqCostWeight :   uniformDrift({a: 0, b: 5, w: 1})

  } : console.error('unknown modelspecification: ' + config.modelVersion + ' ' + config.costs + ' ' + config.semantics));
  
  var semanticParams = (config.modelVersion === 'colorSize' ? {

    colorTyp :   uniformDrift({a: .5, b: 1, w: .5/20}),
    sizeTyp :    uniformDrift({a: .5, b: 1, w: .5/20}),
    typWeight :  1

  } : config.semantics === 'fixed' ? {

    colorTyp :   uniformDrift({a: .5, b: 1, w: .5/20}),
    typeTyp :    uniformDrift({a: .5, b: 1, w: .5/20}),
    typWeight :  1    

  } : config.semantics === 'empirical' ? {

    typWeight :  uniformDrift({a: 0, b: 5, w: 1})    

  } : config.semantics === 'fixedplusempirical' ? {

    colorTyp :   uniformDrift({a: .5, b: 1, w: .5/20}),
    typeTyp :    uniformDrift({a: .5, b: 1, w: .5/20}),
    typWeight :  uniformDrift({a: 0, b: 5, w: 1})   

  } : console.error('unknown modelspecification: model version: ' 
    + config.modelVersion + '; costs: ' + config.costs + '; semantics: ' + config.semantics));     

  return extend(config, baseParams, costParams, semanticParams);
};

var modelAnalysis = function() {

  var params = paramPrior();
  var lexicon = refModule.constructLexicon(params);
  var modelParams = extend(params, {lexicon});
  var likelihood = reduce(function(c, memo) {
    // Extract condition information
    var context = c.context;
    var target = context[0];
    
    // Condition on data
    var itemData = refModule.getSubset(data, _.omit(c, 'context'));
    return memo + reduce(function(datum, memo) {
      return memo + refModule.getSpeakerScore(datum.response, target, context, modelParams);
    }, 0, itemData);
  }, 0, conditions);

  factor(likelihood);
  console.log(likelihood);
  
  var paramsKey = _.values(_.omit(params, ['modelVersion','costs','semantics'])).join(',');
  return {
    output : _.zipObject([paramsKey], [likelihood]),
    // version: params.modelVersion + '_params:obj'
    version: params.modelVersion + '_' + params.costs + '_' + params.semantics + '_params:obj'
  };
};

// Some versions take longer to run than others, so we tune settings to match
var inferenceSettings = {
  model: modelAnalysis, method:'MCMC', verbose: true,
  samples: config.modelVersion == 'colorSize' ? 2000 : 1000,
  lag: config.modelVersion == 'colorSize' ? 10 : 5,
  burn: config.modelVersion == 'colorSize' ? 10000 : 7500
};

// var inferenceSettings = {
//   model: modelAnalysis, method:'MCMC', verbose: true,
//   samples: config.modelVersion == 'colorSize' ? 2000 : 10000,
//   lag: config.modelVersion == 'colorSize' ? 10 : 10,
//   burn: config.modelVersion == 'colorSize' ? 10000 : 10000
// };

//modelAnalysis();
var outputERP = Infer(inferenceSettings);
// console.log(outputERP);

refModule.bayesianErpWriter(outputERP);
