var initializeModel = function(params) {
  // TODO
  // 1. make sure context is in same format for all (i.e. list of lists?)
  var possibleUtts = function(target, context) {
    if (params.modelVersion === 'colorSize') {
      return refModule.getColorSizeUtterances(context);
    } else if(params.modelVersion === 'nominal') {
      return refModule.getNominalUtterances(target.item, params.lexicon);
    } else if(params.modelVersion === 'typicality') {
      return refModule.getTypicalityUtterances(context);
    } else {
      return console.error('unknown modelVersion: ' + params.modelVersion);
    }
  };
  
  // Cost of utterance
  // TODO
  // 1. double-check colors, types, sizes
  // 2. make sure length/freq either looks at right json or uses combined json
  var uttCost = function(utt) {    
    if(params.modelVersion === 'colorSize') {
      var colorMention = _.intersection(refModule.colors, utt.split('_')).length;
      var sizeMention = _.intersection(refModule.sizes, utt.split('_')).length;
      return (params.colorCost * colorMention +
  	      params.sizeCost * sizeMention);
    } else if (_.includes(['nominal', 'typicality'], params.modelVersion))  {
      return (params.lengthCost * refModule.getRelativeLength(params, utt) +
  		 params.freqCost * refModule.getRelativeLogFrequency(params, utt));
    } else {
      return console.error('unknown modelVersion: ' + params.modelVersion);
    }
  };

  // Looks up meaning in given lexicon
  var meaning = function(utt, object) {
    var objStr = _.values(object).join("_");
    var lexicalEntry = params.lexicon[utt];
    return _.has(lexicalEntry, objStr) ? lexicalEntry[objStr] : 0; 
  };
  
  // Selects among objects in context using lexicon
  var literalListener = cache(function(utt, context){
    return Infer({method:'enumerate', model: function(){
      var object = uniformDraw(context);
      factor(params.typWeight * meaning(utt,object)); 
      return object;
    }});
  });
  
  // Selects among utterances given informativity in context and cost of production,
  // marginalizing over possible noise in perception of context
  // Timeit note: marginalizing over listener takes about 200-300ms per utt; pure js is faster
  var speaker = function(target, context) {
    var utts = possibleUtts(target, context);
    return Infer({method:'enumerate', model: function(){
      var utt = uniformDraw(utts);
      // this is a fast shortcut for literalListener(utt, context).score(target)
      var utility = (params.alpha * literalListener(utt, context).score(target)
      		     - uttCost(utt));
      factor(utility);
      return utt;
    }});
  };

  return speaker;
};
