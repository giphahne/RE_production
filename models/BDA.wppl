// run using:
// webppl BDA.wppl --require ./refModule/ -- --modelVersion <colorSize> --costs <fixed> --semantics <empirical> 

// modelVersion can be <colorSize> <typicality> <nominal>
// costs can be <fixed> <empirical>
// semantics can be <fixed> <empirical> <fixedplusempirical>

// Fix some configuration options
var config = {
  'modelVersion' : argv.modelVersion,
  'costs' : argv.costs,
  'semantics' : argv.semantics
};

// Pull in requested data/conditions 
var data = refModule.getData(config.modelVersion);
console.log("Loading data... found" + data.length + " data points");

var conditions = refModule.getConditions(config.modelVersion);
console.log("Loading unique conditions... found" + conditions.length);

var getSemanticParams = function(semantics) {
  if(semantics === 'fixed') {
    return {
      colorTyp : uniformDrift({a: .5, b: 1, w: .5/20}),
      sizeTyp : config.modelVersion == 'colorSize' ? uniformDrift({a: .5, b: 1, w: .5/20}) : 0,
      typeTyp : config.modelVersion == 'typicality' ? uniformDrift({a: .5, b: 1, w: .5/20}) : 0,
      typWeight : 1
    };
  } else if (semantics === 'empirical') {
    return {
      typWeight :  uniformDrift({a: 0, b: 5, w: 1})
    };
  } else {
    console.error('unknown modelspecification: model version: ' + config.modelVersion +
		  '; costs: ' + config.costs + '; semantics: ' + config.semantics);
  }
};

var paramPrior = function() {
  // Params shared by all versions of the model
  var baseParams = {
    infWeight : uniformDrift({a: 0, b: 50, w: 40/20})
  };

  var costParams = (config.costs === 'fixed'  ? {
    colorCost : uniformDrift({a: 0, b: 10, w: 10/20}),
    sizeCost :  config.modelVersion == 'colorSize' ? uniformDrift({a: 0, b: 10, w: 10/20}) : 0,
    typeCost :  config.modelVersion == 'typicality' ? uniformDrift({a: 0, b: 10, w: 10/20}) : 0
  } : config.costs === 'empirical' ? {
    lengthCostWeight : uniformDrift({a: 0, b: 5, w: 1}),
    freqCostWeight :   uniformDrift({a: 0, b: 5, w: 1})
  } : console.error('unknown modelspecification: ' + config.modelVersion + ' ' +
		    config.costs + ' ' + config.semantics));
  
  var semanticParams = (config.semantics == 'fixedplusempirical' ?
			extend(getSemanticParams('fixed'), getSemanticParams('empirical'),
			       {fixedVsEmpirical: uniformDrift({a: 0, b: 1, w: 1/20})}) :
			getSemanticParams(config.semantics));
  return extend(config, baseParams, costParams, semanticParams);
};

var modelAnalysis = function() {
  var params = paramPrior();
  var lexicon = refModule.constructLexicon(params);
  var modelParams = extend(params, {lexicon});
  globalStore.score = 0;
  mapData({data: data, batchSize: 20}, function(datum) {
    var score = refModule.getSpeakerScore(datum.response, datum.context[0], datum.context, modelParams);
    globalStore.score += score;
    factor(score);
  });
  display(globalStore.score);
  var paramsKey = _.values(_.omit(params, ['modelVersion','costs','semantics'])).join(',');
  return {
    output : _.zipObject([paramsKey], [globalStore.score]),
    // version: params.modelVersion + '_params:obj'
    version: params.modelVersion + '_cost-' + params.costs + '_sem-' + params.semantics + '_params:obj'
  };
};

// Some versions take longer to run than others, so we tune settings to match
var inferenceSettings = {
  model: modelAnalysis,
  method:'MCMC',
  verbose: true,
  kernel: 'MH', // (config.modelVersion == 'colorSize' ?
	  //  'MH' : //{HMC: {steps: 2, stepSize: .001}} ://'MH' :
	  //  {HMC: {steps: 10, stepSize: .0005}}), 
  samples: config.modelVersion == 'colorSize' ? 2000 : 100,
  lag: config.modelVersion == 'colorSize' ? 10 : 0,
  burn: config.modelVersion == 'colorSize' ? 10000 : 100
};

var outputERP = Infer(inferenceSettings);

refModule.bayesianErpWriter(outputERP);
